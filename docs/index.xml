<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Programming using the MEAN stack</title>
<date>October 2016</date>
<author>
<personname>
<firstname>Ted</firstname>
<surname>Hagos</surname>
</personname>
<email>ted@thelogbox.com</email>
</author>
<authorinitials>TGH</authorinitials>
<revhistory>
<revision>
<revnumber>1.0</revnumber>
<date>October 2016</date>
<authorinitials>TGH</authorinitials>
</revision>
</revhistory>
</info>
<preface xml:id="preface">
<title>Preface</title>
<section xml:id="what_you_should_know">
<title>What you should know</title>
<simpara>Ideally you are approaching the book with some background on the
following areas</simpara>
<itemizedlist>
<listitem>
<simpara>Javascript client side programming</simpara>
</listitem>
<listitem>
<simpara>Web development experience from any programming language e.g. PHP,
ASP, Java etc</simpara>
</listitem>
<listitem>
<simpara>Database programming background e.g. MySQL, SQLServer, Oracle, DB2,
SQLite etc</simpara>
</listitem>
</itemizedlist>
<simpara>You don&#8217;t need to be an expert on the above fields, but a modest
amount of experience in them will certainly go a long way.</simpara>
</section>
<section xml:id="chapter_summaries">
<title>Chapter Summaries</title>
<variablelist>
<varlistentry>
<term>Chapter 1</term>
<listitem>
<simpara>A Javascript refresher. Ideally, you will approach the book with book with some Javascript experience</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Chapter 2</term>
<listitem>
<simpara>Whatever chapter 2 is</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>This is the end of the preface</simpara>
</section>
</preface>
<chapter xml:id="javascript_concepts">
<title>Javascript Concepts</title>
<itemizedlist>
<listitem>
<simpara>JS is compiled</simpara>
</listitem>
<listitem>
<simpara>The LHS and RHS</simpara>
</listitem>
</itemizedlist>
<section xml:id="scope">
<title>Scope</title>

</section>
<section xml:id="this_and_super">
<title>This and Super</title>

</section>
<section xml:id="callback">
<title>Callback</title>

</section>
<section xml:id="es6">
<title>ES6</title>

</section>
</chapter>
<chapter xml:id="nodejs">
<title>NodeJS</title>
<section xml:id="installation">
<title>Installation</title>
<simpara>NodeJS is available in a variety of platforms and it can be installed
on each of those platforms in a couple of ways. It can installed by
<emphasis role="strong">(a)</emphasis> downloading and installing a precompiled binary <emphasis role="strong">(b)</emphasis> using your
platforms package manager <emphasis role="strong">(c)</emphasis> compiling from source and <emphasis role="strong">(d)</emphasis> using the
node version manager. Each of these routes have their own advantages
and disadvantages and they differ in level of difficulty.</simpara>
<simpara>The most difficult route is probably option (c) compilation from source. But it
is also the most flexible because you can control what features gets
compiled and what doesn&#8217;t. The easiest route is option (a) using a
precompiled binary because this only entails downloading, double
clicking and following an installation wizard. Nothing you haven&#8217;t
seend before. You would install nodejs the way you would install any
other application in your platform.</simpara>
<simpara>Options (b) using a package manager, and (d) using nvm are of somewhat
equal footing in terms of difficulty. But we will use nvm whenever
possible because it allows us to install multiple versions of node on
a single machine.</simpara>
<section xml:id="linux_and_osx">
<title>Linux and OSX</title>
<simpara>You can use your respective package managers like aptitude and
HomeBrew, for Linux and OSX respectively. Alternatively, you can use
the node version manager (nvm) instead. NVM is a popular way of
installing the node runtime and tools on both OSX and Linux. NVM
allows us to install multiple versions of node on a single machine. If
you are working, or will work, on projects that will use different
versions of node, nvm is an ideal solution.</simpara>
<simpara>You will need to install <literal>curl</literal> on your system before you can proceed
with the installation of nvm.</simpara>
<screen>brew install curl <co xml:id="CO1-1"/>
sudo apt-get install curl <co xml:id="CO1-2"/></screen>
<calloutlist>
<callout arearefs="CO1-1">
<para>Use this command if you are on OSX and using HomeBrew as a package
manager</para>
</callout>
<callout arearefs="CO1-2">
<para>Do this if you are on Debian derivative Linux distro</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>apt-get</literal> package manager is for the Debian or Linux distros
that are derived from Debian e.g. Ubuntu, Mint etc. If you are using
Fedora or ArchLinux, see your distributions documentation on how to
get software from your respective repos. I used the Debian technique
here because I am assuming that most people who will read this will
run some version of Ubuntu, it is probably one of the most popular
distros in wide use today</simpara>
</note>
<simpara>Next, we&#8217;ll pull the installer via curl. Paste or type the following command on
your terminal window.</simpara>
<screen>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash</screen>
<simpara>Wait for the command to finish. After that, node would have been
installed on your system.</simpara>
<note>
<simpara>At the time of this writing, the version of nvm is <emphasis role="strong">v0.3.2</emphasis>, you
should always visit the <link xl:href="https://github.com/creationix/nvm">Creationix
page @ github</link> and copy the installer command from that page instead
of directly typing the curl command above into your system</simpara>
</note>
</section>
<section xml:id="windows">
<title>Windows</title>
<simpara>NVM is not officially supported on Windows. There are projects like
nvm-windows and nodist that will allow you to use nvm on a Windows
machine but they are not officially supported. If you still want to
try nvm on a Win machine, there are links to those resources on the
<link xl:href="https://github.com/creationix/nvm">Creationix website @ GitHub</link>.</simpara>
<simpara>For our purpose, we will install node using the precompiled binary
installer.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Download the installer from
<link xl:href="https://nodejs.org/en/download/">nodejs.org website/downloads</link></simpara>
</listitem>
<listitem>
<simpara>Choose installer appropriate for your Windows platform (32 or 64
bit)</simpara>
</listitem>
<listitem>
<simpara>Double click and follow the prompts. Just install it the way you
would normally install any other software on Windows</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="repl">
<title>REPL</title>
<simpara>The node REPL (Read Eval Print Loop) is an interactive shell where you
can enter Javascript expressions, statements and even control
structures. It is a good way to learn Javascript and node when you are
beginning to explore Node. The REPL needs to be launched from the
command line.</simpara>
<simpara><emphasis role="strong">Windows</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Launch <literal>cmd</literal>. There are many ways to do this in Windows, one of
them is to press the <literal>Win + R</literal> (Windows key or Super key on your
keyboard + R). That will open the <emphasis role="strong">Run</emphasis> dialog, then type <literal>cmd</literal></simpara>
</listitem>
<listitem>
<simpara>Type <literal>node</literal></simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">OSX and Linux</emphasis></simpara>
<simpara>If you&#8217;re working on these platforms, you don&#8217;t need instructions on
how to launch a terminal window. Use whatever terminal is favorite and
then type <literal>node</literal>. You should see the node chevron prompt. Try a couple of commands in it</simpara>
<screen>&gt; var greetings = "Hello"; <co xml:id="CO2-1"/>
&gt; console.log(greetings); <co xml:id="CO2-2"/>

&gt; console.log(Date.now()); <co xml:id="CO2-3"/>

&gt; var r = Math.random(); <co xml:id="CO2-4"/>
&gt; console.log(r)</screen>
<calloutlist>
<callout arearefs="CO2-1">
<para>Assign a string to var <literal>greetings</literal></para>
</callout>
<callout arearefs="CO2-2">
<para>Echo the content of the <literal>greetings</literal> var to the screen</para>
</callout>
<callout arearefs="CO2-3">
<para>Print the current date</para>
</callout>
<callout arearefs="CO2-4">
<para>Generate a random number and assign it to a var</para>
</callout>
</calloutlist>
<simpara>When you want to exit the node REPL, press <literal>CTRL + C</literal> twice</simpara>
</section>
<section xml:id="running_a_script">
<title>Running a Script</title>
<simpara>The REPL is a useful learning tool, but we won&#8217;t use much of it here.
We will run our node programs as scripts. We will write the node
programs in a Javascript source file and then we&#8217;ll run it using the
node runtime.</simpara>
<simpara>In the following example, a program file named <emphasis>multiplication.js</emphasis> is
created. The contents of which is shown below. It&#8217;s a simple
Javascript program to print out a 5x5 multiplication table.</simpara>
<example>
<title>multiplication.js</title>
<literallayout class="monospaced">for(var x = 1; x &lt; 5; x++) {
  for(var y = 1; y &lt; 5; y++) {
    process.stdout.write(x * y + '\t'); <co xml:id="CO3-1"/>
  }
  process.stdout.write('\n'); <co xml:id="CO3-2"/>
}</literallayout>
</example>
<calloutlist>
<callout arearefs="CO3-1">
<para><literal>process.stdout.write</literal> is almost the same as <literal>console.log</literal>. They
will both print out things on the screen. Console.log however, will
add a newline at the end. The <literal>\t</literal> is a string escape sequence, it
will add a tab to the output</para>
</callout>
<callout arearefs="CO3-2">
<para>The <literal>\n</literal> is another escape sequence. This one prints a newline</para>
</callout>
</calloutlist>
<simpara>To run the program, we&#8217;ll invoke the <literal>node</literal> runtime and pass the name
of the program source file as a command line argument.</simpara>
<screen>node multiplication.js</screen>
</section>
</chapter>
<chapter xml:id="hello_world">
<title>Hello World</title>
<itemizedlist>
<listitem>
<simpara>Basic structure</simpara>
</listitem>
<listitem>
<simpara>Response</simpara>
</listitem>
<listitem>
<simpara>Request</simpara>
</listitem>
<listitem>
<simpara>How to get to the body</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="file_io">
<title>File IO</title>
<simpara>I should see this</simpara>
<example>
<title>FileReadExample.js</title>
<screen>const fs = require('fs'); <co xml:id="CO4-1"/>
const filename = 'index.html';

fs.readFile(filename,'utf-8', function(err, data){ <co xml:id="CO4-2"/><co xml:id="CO4-3"/><co xml:id="CO4-4"/>
  if(err) { <co xml:id="CO4-5"/>
    console.log(err.message);
  }
  else {
    console.log(data); <co xml:id="CO4-6"/>
  }
});</screen>
</example>
<calloutlist>
<callout arearefs="CO4-1">
<para>Import the <literal>fs</literal> library into our app. Anything that requires
file io is contained in this module</para>
</callout>
<callout arearefs="CO4-2">
<para>First parameter of <literal>readFile()</literal> is the filename to read. You can
check for file existence first if you prefer using <literal>fs.lstat</literal> or
<literal>fs.access</literal>, but if you generally would just like to read the file,
just call <literal>readFile</literal> right away. If the file does not exist, it will
throw an error just the same</para>
</callout>
<callout arearefs="CO4-3">
<para>Second parameter of <literal>readFile</literal> is the encoding, we simply set it
to utf-8</para>
</callout>
<callout arearefs="CO4-4">
<para>Third parameter is a callback function. When <literal>readFile</literal> eventually
finishes actually reading the file, this function will be called. The
node runtime will pass to our function two things (a) an error object,
should an error occur and (b) if readFile went ahead without problems,
all of the contents of <literal>filename</literal> would have been loaded to the <literal>data</literal>
variable</para>
</callout>
<callout arearefs="CO4-5">
<para>If the call fails, <literal>err</literal> won&#8217;t be null. Lots of things can cause
the <literal>readFile()</literal> to fail e.g. if the file is not there, the OS ran out
of file handles etc. If err isn&#8217;t null, the <literal>if</literal> block will find it
<emphasis>truthy</emphasis></para>
</callout>
<callout arearefs="CO4-6">
<para>If the call succeeds, <literal>err</literal> will be null (falsy) and the
contents of the file would have been loaded into the second parameter
of our callback function</para>
</callout>
</calloutlist>
<simpara>If you ran the code listing above, you would seen  an error message
because the file <emphasis>index.html</emphasis> does not exist yet. Create the html file
and save it on the same folder where <emphasis>FileReadExample.js</emphasis> is located.</simpara>
<example>
<title>Contents of index.html</title>
<screen>&lt;!DOCTYPE html&gt;
  &lt;html&gt;
  &lt;h1&gt;Hello World&lt;/h1&gt;
&lt;/html&gt;</screen>
</example>
<simpara>Run the code sample again. This time, the contents of <emphasis>index.html</emphasis>
will be echoed to the screen.</simpara>
<section xml:id="reading_a_file_from_a_web_app">
<title>Reading a File from a Web App</title>
<simpara>Let&#8217;s use the file reading technique we learned in the last section
and apply it in a simple web app. The basic idea is as follows (1) The
user navigates to the root document or the home page (2) we will call
a function that will read an html file and (3) we will write the
contents of the html file into the <literal>response</literal> stream.</simpara>
<example>
<title>Opening index.html within createServer</title>
<screen>const http = require('http');
const fs = require('fs');

const port = process.env.PORT || 3000;

http.createServer(function(req, res){
  var url = req.url.toUpperCase();
  switch(url) {
    case "/": <co xml:id="CO5-1"/>
      openFile('index.html', res); <co xml:id="CO5-2"/>
      break;
    case "/ABOUT":
      // were in the about page
      break;
    default: <co xml:id="CO5-3"/>
      // Good place to write a 404 response
    }
}).listen(port);

// HELPER FUNCTIONS -----------------------------

function openFile(filename, res) {
  fs.readFile(filename, 'utf-8', function(err, data){
    if(err){
      res.writeHead(400, {'Content-Type':'text/html'});
      console.log(err.message);
      res.write("Error encountered");
    }
    else {
      res.writeHead(200,{'Content-Type':'text/html'});
      res.write(data); res.end();
    }
  });
}</screen>
</example>
<calloutlist>
<callout arearefs="CO5-1">
<para>The user went to the home page, the "/" represents the document
root of our web app</para>
</callout>
<callout arearefs="CO5-2">
<para>Call our <literal>openFile()</literal> function. We&#8217;ll pass two parameters (a) the
name of the html file to open and (b) the response object</para>
</callout>
<callout arearefs="CO5-3">
<para>If we get to this part of the switch, that means the user typed a
URL address that we don&#8217;t intend to respond to. This is a good place
to put a <emphasis>404 Page Not Found error</emphasis>.</para>
</callout>
</calloutlist>
<simpara>TODO: Why do we need to pass the response object</simpara>
</section>
<section xml:id="synchronous_file_operation">
<title>Synchronous File Operation</title>

</section>
<section xml:id="dealing_with_asynchrony">
<title>Dealing with Asynchrony</title>

</section>
</chapter>
<chapter xml:id="middleware">
<title>Middleware</title>
<itemizedlist>
<listitem>
<simpara>Router</simpara>
</listitem>
<listitem>
<simpara>bodyparser</simpara>
</listitem>
<listitem>
<simpara>CommonJS</simpara>
</listitem>
<listitem>
<simpara>Rack</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="relational_databases">
<title>Relational Databases</title>
<section xml:id="mysql">
<title>MySQL</title>

</section>
<section xml:id="postgresql">
<title>PostgreSQL</title>

</section>
<section xml:id="sqlite">
<title>SQLite</title>

</section>
</chapter>
<chapter xml:id="mongodb">
<title>MongoDB</title>
<section xml:id="nosql_and_rdbms">
<title>NoSQL and RDBMS</title>

</section>
<section xml:id="installation_and_config">
<title>Installation and Config</title>
<simpara>There are a couple of ways to install MongoDB on whatever platform you
are using. We can use (a) precompiled installer binaries (b) use our
platform&#8217;s package manager e.g. brew, apt-get, yum, chocolatey etc. or
 (c) we can compile it from source. For our purposes, we will simply
 use the pre-compiled binaries.</simpara>
<section xml:id="linux_and_osx_2">
<title>Linux and OSX</title>
<simpara>Launch a browser window then head over to <link xl:href="http://mongodb.org">MongoDB
website</link>. There should be a download link on the front page, click and
follow that link. At the time of writing, there are two editions of
MongoDB that can be downloaded, these are (a) Community server, this
is free for use version. It is the one we will download, and
(b) Enterprise server, this is the commercial version.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Choose the community server edition</simpara>
</listitem>
<listitem>
<simpara>Choose either Linux or OSX</simpara>
</listitem>
<listitem>
<simpara>Pay attention to the version dropdown list. If you are on Linux,
there are a couple of choices on the dropdown list. Do not be so
quick to hit the download button. Make sure that your Linux distro
is the one selected on the dropdown</simpara>
</listitem>
<listitem>
<simpara>Click the download button</simpara>
</listitem>
<listitem>
<simpara>At the time of this writing, the Linux and OSX installers comes as
a <emphasis>tgz</emphasis> file. Use the tar archiver tool to expand the installer
<literal>tar -xzvf mongodb-osxOrLinux-x86_64-XXX.tgz</literal></simpara>
</listitem>
</orderedlist>
<simpara>Move it, include it on your system path
create /data/db file
sudo chown -R <literal>id -u</literal> /data/db</simpara>
<simpara>mongod
mongo</simpara>
</section>
<section xml:id="windows_2">
<title>Windows</title>

</section>
</section>
<section xml:id="inserting_documents">
<title>Inserting documents</title>

</section>
<section xml:id="finding_documents">
<title>Finding documents</title>

</section>
<section xml:id="deleting_documents">
<title>Deleting documents</title>

</section>
<section xml:id="updating_documents">
<title>Updating documents</title>

</section>
<section xml:id="mongoose">
<title>Mongoose</title>
<itemizedlist>
<listitem>
<simpara>Models</simpara>
</listitem>
<listitem>
<simpara>Schemas</simpara>
</listitem>
<listitem>
<simpara>Basic uses in an app</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="express">
<title>Express</title>

</chapter>
<chapter xml:id="route_parameters">
<title>Route Parameters</title>

</chapter>
<chapter xml:id="templating_in_express">
<title>Templating in Express</title>
<itemizedlist>
<listitem>
<simpara>SWIG</simpara>
</listitem>
<listitem>
<simpara>EJS or Jade</simpara>
</listitem>
<listitem>
<simpara>Moustache</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="logging">
<title>Logging</title>
<itemizedlist>
<listitem>
<simpara>Winston</simpara>
</listitem>
<listitem>
<simpara>Why not console.log</simpara>
</listitem>
<listitem>
<simpara>Other choices</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="angularjs">
<title>AngularJS</title>
<itemizedlist>
<listitem>
<simpara>Basic usage</simpara>
</listitem>
<listitem>
<simpara>Modules</simpara>
</listitem>
<listitem>
<simpara>Routes</simpara>
</listitem>
<listitem>
<simpara>Models</simpara>
</listitem>
<listitem>
<simpara>Should I use 1.5 or 2</simpara>
</listitem>
<listitem>
<simpara>Why not polymer</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="authentication">
<title>Authentication</title>
<itemizedlist>
<listitem>
<simpara>Homegrown solution</simpara>
</listitem>
<listitem>
<simpara>Passport</simpara>
</listitem>
<listitem>
<simpara>Passport strategies</simpara>
</listitem>
<listitem>
<simpara>Using the local strategy</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>
