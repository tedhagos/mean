<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Programming using the MEAN stack</title>
<date>October 2016</date>
<author>
<personname>
<firstname>Ted</firstname>
<surname>Hagos</surname>
</personname>
<email>ted@thelogbox.com</email>
</author>
<authorinitials>TGH</authorinitials>
<revhistory>
<revision>
<revnumber>1.0</revnumber>
<date>October 2016</date>
<authorinitials>TGH</authorinitials>
</revision>
</revhistory>
</info>
<preface xml:id="preface">
<title>Preface</title>
<section xml:id="what_you_should_know">
<title>What you should know</title>
<simpara>Ideally you are approaching the book with some background on the
following areas</simpara>
<itemizedlist>
<listitem>
<simpara>Javascript client side programming</simpara>
</listitem>
<listitem>
<simpara>Web development experience from any programming language e.g. PHP,
ASP, Java etc</simpara>
</listitem>
<listitem>
<simpara>Database programming background e.g. MySQL, SQLServer, Oracle, DB2,
SQLite etc</simpara>
</listitem>
</itemizedlist>
<simpara>You don&#8217;t need to be an expert on the above fields, but a modest
amount of experience in them will certainly go a long way.</simpara>
</section>
<section xml:id="chapter_summaries">
<title>Chapter Summaries</title>
<variablelist>
<varlistentry>
<term>Chapter 1</term>
<listitem>
<simpara>A Javascript refresher. Ideally, you will approach the book with book with some Javascript experience</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Chapter 2</term>
<listitem>
<simpara>Whatever chapter 2 is</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>This is the end of the preface</simpara>
</section>
</preface>
<chapter xml:id="javascript_concepts">
<title>Javascript Concepts</title>
<itemizedlist>
<listitem>
<simpara>JS is compiled</simpara>
</listitem>
<listitem>
<simpara>The LHS and RHS</simpara>
</listitem>
</itemizedlist>
<section xml:id="scope">
<title>Scope</title>

</section>
<section xml:id="this_and_super">
<title>This and Super</title>

</section>
<section xml:id="callback">
<title>Callback</title>

</section>
<section xml:id="es6">
<title>ES6</title>

</section>
</chapter>
<chapter xml:id="nodejs">
<title>NodeJS</title>
<section xml:id="installation">
<title>Installation</title>
<simpara>NodeJS is available in a variety of platforms and it can be installed
on each of those platforms in a couple of ways. It can installed by
<emphasis role="strong">(a)</emphasis> downloading and installing a precompiled binary <emphasis role="strong">(b)</emphasis> using your
platforms package manager <emphasis role="strong">(c)</emphasis> compiling from source and <emphasis role="strong">(d)</emphasis> using the
node version manager. Each of these routes have their own advantages
and disadvantages and they differ in level of difficulty.</simpara>
<simpara>The most difficult route is probably option (c) compilation from source. But it
is also the most flexible because you can control what features gets
compiled and what doesn&#8217;t. The easiest route is option (a) using a
precompiled binary because this only entails downloading, double
clicking and following an installation wizard. Nothing you haven&#8217;t
seend before. You would install nodejs the way you would install any
other application in your platform.</simpara>
<simpara>Options (b) using a package manager, and (d) using nvm are of somewhat
equal footing in terms of difficulty. But we will use nvm whenever
possible because it allows us to install multiple versions of node on
a single machine.</simpara>
<section xml:id="linux_and_osx">
<title>Linux and OSX</title>
<simpara>You can use your respective package managers like aptitude and
HomeBrew, for Linux and OSX respectively. Alternatively, you can use
the node version manager (nvm) instead. NVM is a popular way of
installing the node runtime and tools on both OSX and Linux. NVM
allows us to install multiple versions of node on a single machine. If
you are working, or will work, on projects that will use different
versions of node, nvm is an ideal solution.</simpara>
<simpara>You will need to install <literal>curl</literal> on your system before you can proceed
with the installation of nvm.</simpara>
<screen>brew install curl <co xml:id="CO1-1"/>
sudo apt-get install curl <co xml:id="CO1-2"/></screen>
<calloutlist>
<callout arearefs="CO1-1">
<para>Use this command if you are on OSX and using HomeBrew as a package
manager</para>
</callout>
<callout arearefs="CO1-2">
<para>Do this if you are on Debian derivative Linux distro</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>apt-get</literal> package manager is for the Debian or Linux distros
that are derived from Debian e.g. Ubuntu, Mint etc. If you are using
Fedora or ArchLinux, see your distributions documentation on how to
get software from your respective repos. I used the Debian technique
here because I am assuming that most people who will read this will
run some version of Ubuntu, it is probably one of the most popular
distros in wide use today</simpara>
</note>
<simpara>Next, we&#8217;ll pull the installer via curl. Paste or type the following command on
your terminal window.</simpara>
<screen>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash</screen>
<simpara>Wait for the command to finish. After that, node would have been
installed on your system.</simpara>
<note>
<simpara>At the time of this writing, the version of nvm is <emphasis role="strong">v0.3.2</emphasis>, you
should always visit the <link xl:href="https://github.com/creationix/nvm">Creationix
page @ github</link> and copy the installer command from that page instead
of directly typing the curl command above into your system</simpara>
</note>
</section>
<section xml:id="windows">
<title>Windows</title>
<simpara>NVM is not officially supported on Windows. There are projects like
nvm-windows and nodist that will allow you to use nvm on a Windows
machine but they are not officially supported. If you still want to
try nvm on a Win machine, there are links to those resources on the
<link xl:href="https://github.com/creationix/nvm">Creationix website @ GitHub</link>.</simpara>
<simpara>For our purpose, we will install node using the precompiled binary
installer.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Download the installer from
<link xl:href="https://nodejs.org/en/download/">nodejs.org website/downloads</link></simpara>
</listitem>
<listitem>
<simpara>Choose installer appropriate for your Windows platform (32 or 64
bit)</simpara>
</listitem>
<listitem>
<simpara>Double click and follow the prompts. Just install it the way you
would normally install any other software on Windows</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="repl">
<title>REPL</title>
<simpara>The node REPL (Read Eval Print Loop) is an interactive shell where you
can enter Javascript expressions, statements and even control
structures. It is a good way to learn Javascript and node when you are
beginning to explore Node. The REPL needs to be launched from the
command line.</simpara>
<simpara><emphasis role="strong">Windows</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Launch <literal>cmd</literal>. There are many ways to do this in Windows, one of
them is to press the <literal>Win + R</literal> (Windows key or Super key on your
keyboard + R). That will open the <emphasis role="strong">Run</emphasis> dialog, then type <literal>cmd</literal></simpara>
</listitem>
<listitem>
<simpara>Type <literal>node</literal></simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">OSX and Linux</emphasis></simpara>
<simpara>If you&#8217;re working on these platforms, you don&#8217;t need instructions on
how to launch a terminal window. Use whatever terminal is favorite and
then type <literal>node</literal>. You should see the node chevron prompt. Try a couple of commands in it</simpara>
<screen>&gt; var greetings = "Hello"; <co xml:id="CO2-1"/>
&gt; console.log(greetings); <co xml:id="CO2-2"/>

&gt; console.log(Date.now()); <co xml:id="CO2-3"/>

&gt; var r = Math.random(); <co xml:id="CO2-4"/>
&gt; console.log(r)</screen>
<calloutlist>
<callout arearefs="CO2-1">
<para>Assign a string to var <literal>greetings</literal></para>
</callout>
<callout arearefs="CO2-2">
<para>Echo the content of the <literal>greetings</literal> var to the screen</para>
</callout>
<callout arearefs="CO2-3">
<para>Print the current date</para>
</callout>
<callout arearefs="CO2-4">
<para>Generate a random number and assign it to a var</para>
</callout>
</calloutlist>
<simpara>When you want to exit the node REPL, press <literal>CTRL + C</literal> twice</simpara>
</section>
<section xml:id="running_a_script">
<title>Running a Script</title>
<simpara>The REPL is a useful learning tool, but we won&#8217;t use much of it here.
We will run our node programs as scripts. We will write the node
programs in a Javascript source file and then we&#8217;ll run it using the
node runtime.</simpara>
<simpara>In the following example, a program file named <emphasis>multiplication.js</emphasis> is
created. The contents of which is shown below. It&#8217;s a simple
Javascript program to print out a 5x5 multiplication table.</simpara>
<example>
<title>multiplication.js</title>
<literallayout class="monospaced">for(var x = 1; x &lt; 5; x++) {
  for(var y = 1; y &lt; 5; y++) {
    process.stdout.write(x * y + '\t'); <co xml:id="CO3-1"/>
  }
  process.stdout.write('\n'); <co xml:id="CO3-2"/>
}</literallayout>
</example>
<calloutlist>
<callout arearefs="CO3-1">
<para><literal>process.stdout.write</literal> is almost the same as <literal>console.log</literal>. They
will both print out things on the screen. Console.log however, will
add a newline at the end. The <literal>\t</literal> is a string escape sequence, it
will add a tab to the output</para>
</callout>
<callout arearefs="CO3-2">
<para>The <literal>\n</literal> is another escape sequence. This one prints a newline</para>
</callout>
</calloutlist>
<simpara>To run the program, we&#8217;ll invoke the <literal>node</literal> runtime and pass the name
of the program source file as a command line argument.</simpara>
<screen>node multiplication.js</screen>
</section>
</chapter>
<chapter xml:id="hello_world">
<title>Hello World</title>
<simpara>A web application written in node will need to create a server,
specifically an HTTP server. The code listing below shows the basic
steps in creating such as a server</simpara>
<example>
<title>Simple Web server</title>
<literallayout class="monospaced">const http = require('http'); <co xml:id="CO4-1"/>

const app = http.createServer(fnWhenSomethingConnects); <co xml:id="CO4-2"/> <co xml:id="CO4-3"/>
app.listen(3000); <co xml:id="CO4-4"/> <co xml:id="CO4-5"/></literallayout>
</example>
<calloutlist>
<callout arearefs="CO4-1">
<para><literal>http</literal> is a built-in module that comes with node. A module is
basically a Javascript source file that contains specific
functionality. In this case, the http module contains all the codes we
need in order to listen to incoming HTTP request and also respond to
these request. When you want to use a module, you need to <literal>require</literal> it
inside your app and assign it to a variable. Well, in this case, I
assigned it to a constant because I don&#8217;t intend to make anymore
changes to <literal>http</literal> after I&#8217;ve defined it</para>
</callout>
<callout arearefs="CO4-2">
<para><literal>createServer()</literal> is a method of the http object. It&#8217;s the one
responsible for, well, creating an HTTP server. This method will
return an instance of an HTTP server which we will use to later to
start the application</para>
</callout>
<callout arearefs="CO4-3">
<para><literal>fnWhenSomethingConnects</literal>. This is a function that we haven&#8217;t
defined yet, but we will very shorty. The <literal>createServer</literal> method
expects a function (either named or anonymous). When an http client e.g. a web browser, tries to connect
to our server, this function will be called</para>
</callout>
<callout arearefs="CO4-4">
<para><literal>listen</literal>. This is a method of an HTTP server. When this method is
called, it will start our web server</para>
</callout>
<callout arearefs="CO4-5">
<para><literal>3000</literal>. The port number I chose. You can choose another number,
preferably higher than 1024. This means that our server will listen
only on port 3000. So any client who wants to talk to our server, will
need to make a request like this <literal><link xl:href="http://localhost:3000">http://localhost:3000</link></literal></para>
</callout>
</calloutlist>
<note>
<simpara><literal>const</literal> keyword is available only on ES6. The node version I am
using for all the examples in this book is v6.3.1, it perfectly
capable of understanding ES6 syntax</simpara>
</note>
<warning>
<simpara>Using port numbers lower than 1024 might require that you run
your node process as a superuser (root). These ports are privileged
ports in *NIX systems</simpara>
</warning>
<simpara>You cannot run the code as it stands right now because we haven&#8217;t
defined <literal>fnWhenSomethingConnects</literal>, so let&#8217;s define that now. We&#8217;ll
make it simple and return a very uninspired hello world.</simpara>
<example>
<title>fnWhenSomethingConnects</title>
<literallayout class="monospaced">function fnWhenSomethingConnects(request, response) { <co xml:id="CO5-1"/> <co xml:id="CO5-2"/>

  response.writeHead(200, {'Content-Type':'text/html'}); <co xml:id="CO5-3"/> <co xml:id="CO5-4"/> <co xml:id="CO5-5"/>
  response.write("&lt;html&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/html&gt;"); <co xml:id="CO5-6"/>
  response.end(); <co xml:id="CO5-7"/>

}</literallayout>
</example>
<calloutlist>
<callout arearefs="CO5-1">
<para>The HTTP <literal>request</literal> object, together with the <literal>response</literal> object are
passed to us when a client tries to connect to our application. The
request object contains quite a lot of information e.g. the URL that
the client invoked or any information that the client passed to the
request like form data for example</para>
</callout>
<callout arearefs="CO5-2">
<para>This is an HTTP <literal>response</literal> object. This is what we will use to
communicate back to the client. When you want the user to see
something, you simply write that information to the response object</para>
</callout>
<callout arearefs="CO5-3">
<para><literal>writeHead</literal> will write the header information of our response. It
has 2 parameters (1) HTTP response and (2) the MIME type</para>
</callout>
<callout arearefs="CO5-4">
<para><literal>200</literal> is the HTTP response code which means the client request was
est. This is the <literal>OK</literal> status of HTTP</para>
</callout>
<callout arearefs="CO5-5">
<para>Were just sending a simple HTML type of response. You can send
other types like JSON or plain text</para>
</callout>
<callout arearefs="CO5-6">
<para>The <literal>write</literal> method takes in a String argument. Whatever you put in
this string parameter will be sent to the client</para>
</callout>
<callout arearefs="CO5-7">
<para>The <literal>response</literal> object is a stream. Calling the <literal>end</literal> method
signals to the client that we are done composing our response and that
the client can start rendering the same response on his end. If you
fail to call the <literal>end</literal> method, the client will wait forever (or until
it times out) for a response from the server</para>
</callout>
</calloutlist>
<simpara>Below is the full code listing for our simple web server</simpara>
<example>
<title>simpleWebServer.js</title>
<literallayout class="monospaced">const http = require('http');

const app = http.createServer(fnWhenSomethingConnects);
app.listen(3000);

function fnWhenSomethingConnects(request, response) {

  response.writeHead(200, {'Content-Type':'text/html'});
  response.write("&lt;html&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/html&gt;");
  response.end();

}</literallayout>
</example>
<simpara>To run this code, type the following on the command line</simpara>
<literallayout class="monospaced">node simpleWebServer.js</literallayout>
<simpara>Launch a browser and navigate to <link xl:href="http://localhost:3000">http://localhost:3000</link></simpara>
<section xml:id="refactoring_simplewebserver">
<title>Refactoring SimpleWebServer</title>
<simpara>While our app is now functional and can respond to simple requests, it
is not written in idiomatic node. It is not in the form that you might
see often on code examples from the web e.g. stackoverflow. It is
readable and verbose, which is not necessarily a bad thing, but I
think we need to familiarize ourselves with how other programmers are
writing their codes. I&#8217;ve refactored the code example. It is shown on
the listing below</simpara>
<example>
<title>simpleWebServer v2</title>
<literallayout class="monospaced">const http = require('http');

const app = http.createServer(function (req,res){ <co xml:id="CO6-1"/>

  response.writeHead(200, {'Content-Type':'text/html'});
  response.write("&lt;html&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/html&gt;");
  response.end();

});

app.listen(3000, function(){ <co xml:id="CO6-2"/>
  console.log("Started the App");
});</literallayout>
</example>
<calloutlist>
<callout arearefs="CO6-1">
<para>The named function <literal>fnWhenSomethingConnects</literal> has disappeared. In
its place instead is the full literal defintion of the function. You
will also notice that the function, right now, has no name. This is
what other programmers refer to as an anonymous function. I don&#8217;t
agree with this because I really think we should always name our
functions, but I&#8217;m just trying to illustrate how other programmer&#8217;s
might code, so let&#8217;s let it slide for now</para>
</callout>
<callout arearefs="CO6-2">
<para>The <literal>listen</literal> method now gets a second parameter. The anonymous
function will be called once our server has successfully bound the
socket, which means it has completed the startup process and is now
actively listening on port 3000</para>
</callout>
</calloutlist>
</section>
<section xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Response</simpara>
</listitem>
<listitem>
<simpara>Request</simpara>
</listitem>
<listitem>
<simpara>How to get to the body</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="file_io">
<title>File IO</title>
<example>
<title>FileReadExample.js</title>
<screen>const fs = require('fs'); <co xml:id="CO7-1"/>
const filename = 'index.html';

fs.readFile(filename,'utf-8', function(err, data){ <co xml:id="CO7-2"/><co xml:id="CO7-3"/><co xml:id="CO7-4"/>
  if(err) { <co xml:id="CO7-5"/>
    console.log(err.message);
  }
  else {
    console.log(data); <co xml:id="CO7-6"/>
  }
});</screen>
</example>
<calloutlist>
<callout arearefs="CO7-1">
<para>Import the <literal>fs</literal> library into our app. Anything that requires
file io is contained in this module</para>
</callout>
<callout arearefs="CO7-2">
<para>First parameter of <literal>readFile()</literal> is the filename to read. You can
check for file existence first if you prefer using <literal>fs.lstat</literal> or
<literal>fs.access</literal>, but if you generally would just like to read the file,
just call <literal>readFile</literal> right away. If the file does not exist, it will
throw an error just the same</para>
</callout>
<callout arearefs="CO7-3">
<para>Second parameter of <literal>readFile</literal> is the encoding, we simply set it
to utf-8</para>
</callout>
<callout arearefs="CO7-4">
<para>Third parameter is a callback function. When <literal>readFile</literal> eventually
finishes actually reading the file, this function will be called. The
node runtime will pass to our function two things (a) an error object,
should an error occur and (b) if readFile went ahead without problems,
all of the contents of <literal>filename</literal> would have been loaded to the <literal>data</literal>
variable</para>
</callout>
<callout arearefs="CO7-5">
<para>If the call fails, <literal>err</literal> won&#8217;t be null. Lots of things can cause
the <literal>readFile()</literal> to fail e.g. if the file is not there, the OS ran out
of file handles etc. If err isn&#8217;t null, the <literal>if</literal> block will find it
<emphasis>truthy</emphasis></para>
</callout>
<callout arearefs="CO7-6">
<para>If the call succeeds, <literal>err</literal> will be null (falsy) and the
contents of the file would have been loaded into the second parameter
of our callback function</para>
</callout>
</calloutlist>
<simpara>If you ran the code listing above, you would seen  an error message
because the file <emphasis>index.html</emphasis> does not exist yet. Create the html file
and save it on the same folder where <emphasis>FileReadExample.js</emphasis> is located.</simpara>
<example>
<title>Contents of index.html</title>
<screen>&lt;!DOCTYPE html&gt;
  &lt;html&gt;
  &lt;h1&gt;Hello World&lt;/h1&gt;
&lt;/html&gt;</screen>
</example>
<simpara>Run the code sample again. This time, the contents of <emphasis>index.html</emphasis>
will be echoed to the screen.</simpara>
<section xml:id="reading_a_file_from_a_web_app">
<title>Reading a File from a Web App</title>
<simpara>Let&#8217;s use the file reading technique we learned in the last section
and apply it in a simple web app. The basic idea is as follows (1) The
user navigates to the root document or the home page (2) we will call
a function that will read an html file and (3) we will write the
contents of the html file into the <literal>response</literal> stream.</simpara>
<example>
<title>Opening index.html within createServer</title>
<screen>const http = require('http');
const fs = require('fs');

const port = process.env.PORT || 3000;

http.createServer(function(req, res){
  var url = req.url.toUpperCase();
  switch(url) {
    case "/": <co xml:id="CO8-1"/>
      openFile('index.html', res); <co xml:id="CO8-2"/>
      break;
    case "/ABOUT":
      // were in the about page
      break;
    default: <co xml:id="CO8-3"/>
      // Good place to write a 404 response
    }
}).listen(port);

// HELPER FUNCTIONS -----------------------------

function openFile(filename, res) {
  fs.readFile(filename, 'utf-8', function(err, data){
    if(err){
      res.writeHead(400, {'Content-Type':'text/html'});
      console.log(err.message);
      res.write("Error encountered");
    }
    else {
      res.writeHead(200,{'Content-Type':'text/html'});
      res.write(data); res.end();
    }
  });
}</screen>
</example>
<calloutlist>
<callout arearefs="CO8-1">
<para>The user went to the home page, the "/" represents the document
root of our web app</para>
</callout>
<callout arearefs="CO8-2">
<para>Call our <literal>openFile()</literal> function. We&#8217;ll pass two parameters (a) the
name of the html file to open and (b) the response object</para>
</callout>
<callout arearefs="CO8-3">
<para>If we get to this part of the switch, that means the user typed a
URL address that we don&#8217;t intend to respond to. This is a good place
to put a <emphasis>404 Page Not Found error</emphasis>.</para>
</callout>
</calloutlist>
<simpara>TODO: Why do we need to pass the response object</simpara>
</section>
<section xml:id="synchronous_file_operation">
<title>Synchronous File Operation</title>

</section>
<section xml:id="dealing_with_asynchrony">
<title>Dealing with Asynchrony</title>

</section>
</chapter>
<chapter xml:id="middleware">
<title>Middleware</title>
<itemizedlist>
<listitem>
<simpara>Router</simpara>
</listitem>
<listitem>
<simpara>bodyparser</simpara>
</listitem>
<listitem>
<simpara>CommonJS</simpara>
</listitem>
<listitem>
<simpara>Rack</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="relational_databases">
<title>Relational Databases</title>
<section xml:id="mysql">
<title>MySQL</title>

</section>
<section xml:id="postgresql">
<title>PostgreSQL</title>

</section>
<section xml:id="sqlite">
<title>SQLite</title>

</section>
</chapter>
<chapter xml:id="mongodb">
<title>MongoDB</title>
<section xml:id="nosql_and_rdbms">
<title>NoSQL and RDBMS</title>
<simpara>If you are new to NoSQL, it might help to see the difference (or
similarities) between the vocabulary of SQL and mongoDB. The following
table illustrates some terms in SQL and their counterparts in mongoDB.</simpara>
<table frame="topbot" rowsep="1" colsep="1">
<title>SQL vs mongoDB</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">SQL</entry>
<entry align="left" valign="top">mongoDB</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>database</simpara></entry>
<entry align="left" valign="top"><simpara>database</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>table</simpara></entry>
<entry align="left" valign="top"><simpara>collection</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>row</simpara></entry>
<entry align="left" valign="top"><simpara>document</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>column</simpara></entry>
<entry align="left" valign="top"><simpara>field</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>index</simpara></entry>
<entry align="left" valign="top"><simpara>index</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>table joins</simpara></entry>
<entry align="left" valign="top"><simpara>embedded documents and linking</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="installation_and_config">
<title>Installation and Config</title>
<simpara>There are a couple of ways to install MongoDB on whatever platform you
are using. We can use (a) precompiled installer binaries (b) use our
platform&#8217;s package manager e.g. brew, apt-get, yum, chocolatey etc. or
 (c) we can compile it from source. For our purposes, we will simply
 use the pre-compiled binaries.</simpara>
<section xml:id="linux_and_osx_2">
<title>Linux and OSX</title>
<simpara>Launch a browser window then head over to <link xl:href="http://mongodb.org">MongoDB
website</link>. There should be a download link on the front page, click and
follow that link. At the time of writing, there are two editions of
MongoDB that can be downloaded, these are (a) Community server, this
is free for use version. It is the one we will download, and
(b) Enterprise server, this is the commercial version.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Choose the community server edition</simpara>
</listitem>
<listitem>
<simpara>Choose either Linux or OSX</simpara>
</listitem>
<listitem>
<simpara>Pay attention to the version dropdown list. If you are on Linux,
there are a couple of choices on the dropdown list. Do not be so
quick to hit the download button. Make sure that your Linux distro
is the one selected on the dropdown</simpara>
</listitem>
<listitem>
<simpara>Click the download button</simpara>
</listitem>
<listitem>
<simpara>At the time of this writing, the Linux and OSX installers comes as
a <emphasis>tgz</emphasis> file. Use the tar archiver tool to expand the installer
<literal>tar -xzvf mongodb-osxOrLinux-x86_64-XXX.tgz</literal></simpara>
</listitem>
<listitem>
<simpara>The expanded contains a directory where all the executables for
mongodb are located. You need to include this in your system path.
This can be accomplished by appending  the following lines to your
startup login script (<literal>~/.bashrc</literal> for Linux and <literal>~/.bash_profile</literal>
for macOS)</simpara>
<screen>set MONGO_HOME=/path/where/you/extracted/mongo/installer
set PATH=$MONGO_HOME/bin:$PATH</screen>
</listitem>
<listitem>
<simpara>Exit command line shell and start another command line session, so
that your changes can take effect</simpara>
</listitem>
<listitem>
<simpara>Create the database file for mongoDB</simpara>
<screen>sudo mkdir /data/db
sudo chown `id -u` /data/db <co xml:id="CO9-1"/></screen>
<calloutlist>
<callout arearefs="CO9-1">
<para><literal>id -u</literal> evaluates to the currently logged in user. Please be
careful when writing this command, note that the <literal>id -u</literal> is
surrounded by backticks and not single quotes</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Start the mongoDB server using the command</simpara>
<screen>mongod</screen>
<simpara>This is a server process, so your command line session won&#8217;t go
back to the shell prompt. To exit this process, press <literal>CTRL+C</literal>, but
don&#8217;t do it just yet because you need this process running if you
want to communicate with the database. Terminate it when you&#8217;re
done with the database tasks</simpara>
</listitem>
<listitem>
<simpara>To start working on a database, launch the mongo client. You may
need to open another command line session for this</simpara>
<screen>mongo
&gt; <co xml:id="CO10-1"/></screen>
<calloutlist>
<callout arearefs="CO10-1">
<para>This the mongoDB prompt, it looks the same as the node REPL, and
like it, it is also an interactive prompt for Javascript</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<note>
<simpara>If you installed the mongo db file in a location other than
<literal>/data/db</literal>, you need to use the <literal>--dbpath</literal> option when starting the
mongod server e.g. <literal>mongod --dbpath /path/to/data/db</literal></simpara>
</note>
</section>
<section xml:id="windows_2">
<title>Windows</title>
<simpara>The mongoDB installer comes in 2 editions for Windows, at the time of
this writing. These are (a) <emphasis role="strong">MongoDB for Windows 64-bit</emphasis> which runs
only on Windows Server 2008 R2, Windows 7 64-bit, and newer versions
of Windows. This build takes advantage of recent enhancements to the
Windows Platform and cannot operate on older versions of Windows; and
(b) <emphasis role="strong">MongoDB for Windows 64-bit Legacy</emphasis> which  runs on Windows Vista,
and Windows Server 2008 and does not include recent performance
enhancements. You need to find out which Windows version you are
running. The following commands should help you find out. Launch
either a <literal>cmd</literal> window or Powershell</simpara>
<literallayout class="monospaced">wmic os get caption
wmic os get osarchitecture</literallayout>
<simpara>Launch a browser window then head over to <link xl:href="http://mongodb.org">MongoDB
website</link>. There should be a download link on the front page, click and
follow that link. At the time of writing, there are two editions of
MongoDB that can be downloaded, these are (a) Community server, this
is free for use version. It is the one we will download, and
(b) Enterprise server, this is the commercial version.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Download the appropriate edition of mongoDB for your platform,
please note that the 64-bit installer will not work on 32-bit
platforms</simpara>
</listitem>
<listitem>
<simpara>Go to the location where you downloaded <literal>.msi</literal> file, usually, this
is the <emphasis>Downloads</emphasis> folder</simpara>
</listitem>
<listitem>
<simpara>Double click the <literal>.msi</literal> file and follow the installation wizard</simpara>
<note>
<simpara>These instructions assume that you have installed MongoDB to
C:\Program Files\MongoDB\Server\x.x\.</simpara>
</note>
</listitem>
<listitem>
<simpara>Open and Administrator command prompt. Press the <literal>Win</literal> key, type
<literal>cmd</literal> and press <literal>CTRL+Shift+Enter</literal> to run the command prompt as an
Administrator</simpara>
</listitem>
<listitem>
<simpara>Create the database and log file for mongoDB</simpara>
<screen>mkdir c:\data\db
mkdir c:\data\log</screen>
</listitem>
<listitem>
<simpara>Start the mongoDB server</simpara>
<screen>"C:\Program Files\MongoDB\Server\x.x\bin\mongod.exe"</screen>
<simpara>This is a server process, you won&#8217;t go back to Windows command line
prompt as long as the server process is running. If you want to
terminate it, you can press <literal>CTRL+C</literal>, but don&#8217;t do it it just yet.
Terminate it when you no longer need the database. We still need it
because on the next step, we will connect to the mongoDB server via
the mongo client</simpara>
</listitem>
<listitem>
<simpara>Launch another <literal>cmd</literal> window and connect to the server</simpara>
<screen>"C:\Program Files\MongoDB\Server\x.x\bin\mongo.exe
&gt; <co xml:id="CO11-1"/></screen>
<calloutlist>
<callout arearefs="CO11-1">
<para>This is the chevron prompt of mongo, it looks the same as the node
REPL prompt, and like it, it also evaluates Javascript expressions,
statements etc</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="basic_usage">
<title>Basic Usage</title>
<simpara><emphasis role="strong">Starting the server</emphasis>. On a terminal window, start the server by running the <literal>mongod</literal>
executable</simpara>
<screen>mongod</screen>
<simpara><emphasis role="strong">Connecting a client</emphasis>. On another terminal window, start the mongo
client by running</simpara>
<screen>mongo</screen>
<simpara>You should get the chevon prompt of mongodb after launching the client
successfully.</simpara>
<simpara><emphasis role="strong">To list all the databases</emphasis>, use the command</simpara>
<screen>&gt; show databases</screen>
<simpara>At this point, you won&#8217;t see much because we haven&#8217;t created any
databases of our own just yet. We&#8217;ll do just that in the next section.</simpara>
<section xml:id="creating_collections_and_documents">
<title>Creating Collections and Documents</title>
<simpara>If we were dealing with a relational database, before we can start
adding a record, we need to (1) create the database first then (2) create
the tables and define its schema, only then can we (3) insert our
first record.</simpara>
<simpara>In mongoDB, we don&#8217;t need to create a pre-defined schema because mongo
databases do not enforce schemas. Schemas are optional, you may or may
not want to use them. If ever you will use schemas, they are not
usually defined on the database level but are rather enforced at an
application level (nodejs). So we can just go ahead and create a
record (document) right away.</simpara>
<simpara>The command snippet below shows a session where we create a database
named <emphasis>crm</emphasis>.</simpara>
<literallayout class="monospaced">mongo <co xml:id="CO12-1"/>
&gt; show databases <co xml:id="CO12-2"/>
&gt; use crm; <co xml:id="CO12-3"/>
&gt; db.clients.count(); <co xml:id="CO12-4"/>
&gt; 0</literallayout>
<calloutlist>
<callout arearefs="CO12-1">
<para>Start the mongo client, you need to make sure that you have
started the <literal>mongod</literal> server on another terminal before you invoke the
<literal>mongo</literal> command</para>
</callout>
<callout arearefs="CO12-2">
<para>You&#8217;ve seen this from the previous section. This will list all the
existing databases in our system. At the moment, this won&#8217;t show much</para>
</callout>
<callout arearefs="CO12-3">
<para>The <literal>use</literal> command will switch databases. At the moment, we haven&#8217;t
defined the <emphasis>crm</emphasis> database yet, but that does not matter to mongo,
it will assume that you actually have that database and switch to it
anyway</para>
</callout>
<callout arearefs="CO12-4">
<para><literal>db</literal> is the alias for the currently used database, in our case,
db is an alias to the <emphasis>crm</emphasis> database. You could think of this command
as <literal>crm.clients.count()</literal>, if that helps. The level of organization
next to the database is a collection (equivalent to a table in RDBMS).
so <literal>db.clients</literal> refers to a collection named <emphasis>clients</emphasis> inside the crm
database. Again, we haven&#8217;t defined any collections yet, but mongo is
very helpful and returns to us the number of records inside the
<emphasis>clients</emphasis> collection anyway (which is zero of course)</para>
</callout>
</calloutlist>
<simpara>Let&#8217;s continue our session with the mongoDB REPL and try to insert
some documents on the <emphasis>clients</emphasis> collection.</simpara>
<literallayout class="monospaced">&gt; db.clients.insert({name: “Air BnB”, contact_owner: “Ted Hagos”,
 contacts: [{name: “John Doe”, email: “johndoe@gmail.com”},
 {name:”Jane Doe”, email:”janedoe@gmail.com”}], projects:
 [{name:”project1”, status: “not moving”}, {name: “project2”}]})</literallayout>
<simpara>The command snippet above maybe a bit ugly to look at, but if you
inspect it closely, the parameter of the <literal>insert</literal> method is a JSON
object, mongoDB documents are actually JSON objects.</simpara>
<simpara>Alternatively,we can create documents this way</simpara>
<literallayout class="monospaced">&gt; var doc = {} <co xml:id="CO13-1"/>
&gt; doc.name = “Air BnB” <co xml:id="CO13-2"/>
&gt; doc.contact_owner = “Ted Hagos” <co xml:id="CO13-3"/>
&gt; doc.contacts = [{name: “John Doe”, email: “johndoe@gmail.com”},
  {name:“Jane Doe”, email:“janedoe@gmail.com”}] <co xml:id="CO13-4"/>
&gt; doc.projects = [{name: “project1”, status: “not moving”}, {name:
  “project2”, status: “not moving”}] <co xml:id="CO13-5"/>
&gt; db.clients.save(doc) <co xml:id="CO13-6"/></literallayout>
<calloutlist>
<callout arearefs="CO13-1">
<para>Create an empty JSON object and assign it variable <literal>doc</literal></para>
</callout>
<callout arearefs="CO13-2">
<para>Create a property named <literal>name</literal>, attach it to the <literal>doc</literal> object. We
assign it a value of "Air BnB"</para>
</callout>
<callout arearefs="CO13-3">
<para>Create a property named <literal>contact_owner</literal>, we assign it a string
value of "Ted Hagos"</para>
</callout>
<callout arearefs="CO13-4">
<para>Create a property named <literal>contacts</literal>, this is an array object which
contains two JSON elements</para>
</callout>
<callout arearefs="CO13-5">
<para>Create a property named <literal>projects</literal>, like <literal>contacts</literal>, this is also
an array object</para>
</callout>
<callout arearefs="CO13-6">
<para>The <literal>save</literal> method performs an insert action as well</para>
</callout>
</calloutlist>
<simpara>MongoDB documents are just JSON objects, so you can pretty much
compose the documents as object literals.</simpara>
</section>
<section xml:id="finding_a_document">
<title>Finding a document</title>

</section>
<section xml:id="updating_a_document">
<title>Updating a document</title>

</section>
<section xml:id="deleting_a_document">
<title>Deleting a document</title>

</section>
<section xml:id="quitting_the_mongo_repl">
<title>Quitting the mongo REPL</title>

</section>
<section xml:id="quitting_the_mongod_server">
<title>Quitting the mongod server</title>

</section>
<section xml:id="sql_commands_vs_mongodb_commands">
<title>SQL commands vs mongoDB commands</title>

</section>
</section>
</chapter>
<chapter xml:id="mongoose">
<title>Mongoose</title>
<itemizedlist>
<listitem>
<simpara>Models</simpara>
</listitem>
<listitem>
<simpara>Schemas</simpara>
</listitem>
<listitem>
<simpara>Basic uses in an app</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="express">
<title>Express</title>

</chapter>
<chapter xml:id="route_parameters">
<title>Route Parameters</title>

</chapter>
<chapter xml:id="templating_in_express">
<title>Templating in Express</title>
<itemizedlist>
<listitem>
<simpara>SWIG</simpara>
</listitem>
<listitem>
<simpara>EJS or Jade</simpara>
</listitem>
<listitem>
<simpara>Moustache</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="logging">
<title>Logging</title>
<itemizedlist>
<listitem>
<simpara>Winston</simpara>
</listitem>
<listitem>
<simpara>Why not console.log</simpara>
</listitem>
<listitem>
<simpara>Other choices</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="angularjs">
<title>AngularJS</title>
<itemizedlist>
<listitem>
<simpara>Basic usage</simpara>
</listitem>
<listitem>
<simpara>Modules</simpara>
</listitem>
<listitem>
<simpara>Routes</simpara>
</listitem>
<listitem>
<simpara>Models</simpara>
</listitem>
<listitem>
<simpara>Should I use 1.5 or 2</simpara>
</listitem>
<listitem>
<simpara>Why not polymer</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="authentication">
<title>Authentication</title>
<itemizedlist>
<listitem>
<simpara>Homegrown solution</simpara>
</listitem>
<listitem>
<simpara>Passport</simpara>
</listitem>
<listitem>
<simpara>Passport strategies</simpara>
</listitem>
<listitem>
<simpara>Using the local strategy</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="notes">
<title>Notes</title>
<itemizedlist mark="none">
<listitem>
<simpara>&#10003; Creating an HTTPS server</simpara>
</listitem>
<listitem>
<simpara>&#10063; Passport Google and Facebook Strategy</simpara>
</listitem>
<listitem>
<simpara>&#10063; Mustache templates/Handlebars templates</simpara>
</listitem>
<listitem>
<simpara>&#10063; Polymer</simpara>
</listitem>
<listitem>
<simpara>&#10063; Material Design</simpara>
</listitem>
<listitem>
<simpara>&#10063; REST discussion</simpara>
</listitem>
<listitem>
<simpara>&#10063; Unit testing</simpara>
<itemizedlist mark="none">
<listitem>
<simpara>&#10063; Unit testing express endpoints</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</chapter>
</book>
